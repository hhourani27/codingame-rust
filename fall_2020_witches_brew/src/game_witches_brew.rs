use common::record;
use common::{Game, Message, StackVector, WinLossTie};
use rand::{rngs, Rng};
use std::collections::HashMap;
use std::fmt;

macro_rules! parse_input {
    ($x:expr, $t:ident) => {
        $x.trim().parse::<$t>().unwrap()
    };
}
#[derive(Copy, Clone, PartialEq, Debug)]
enum Move {
    WAIT,
    BREW(usize),
}

impl fmt::Display for Move {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Move::WAIT => write!(f, "WAIT"),
            Move::BREW(i) => write!(f, "BREW {}", i),
        }
    }
}

type Ingredients = [isize; 4];

#[derive(Copy, Clone)]
struct Order {
    id: usize,
    ingredients: Ingredients,
    price: usize,
}

pub struct WitchesBrewGame {
    // States per player
    moves: [Option<Move>; 2],
    ingredient_stocks: [Ingredients; 2],
    rupees: [usize; 2],
    brewed_potions_count: [usize; 2],

    // Global states
    orders: [Option<Order>; 5],
    next_order_id: usize,
    rnd: rngs::StdRng, // random number generator

    active: bool,
    active_player: u8,
    turn: u8,
    winners: Option<(WinLossTie, WinLossTie)>,
}

impl WitchesBrewGame {
    fn new_with_seed(seed: u64) -> Self {
        let mut game = WitchesBrewGame {
            moves: [None; 2],
            ingredient_stocks: [[2, 2, 3, 3]; 2],
            rupees: [0; 2],
            brewed_potions_count: [0; 2],

            orders: [None; 5],
            next_order_id: 1,
            rnd: rand::SeedableRng::seed_from_u64(seed),

            active: true,
            active_player: 0,
            turn: 0,
            winners: None,
        };

        // Generate orders
        for i in 0..5 {
            game.orders[i] = Some(WitchesBrewGame::generate_order(
                game.next_order_id,
                &mut game.rnd,
            ));

            game.next_order_id += 1;
        }

        game
    }

    fn generate_order(id: usize, rnd: &mut rngs::StdRng) -> Order {
        /* Generate required ingredients
        For each ingredient, the probabilites are :
            60% : 0
            35% : -1
            5%  : -2

        The loop guarantees that a [0,0,0,0] will never be generated
        */
        let mut ingredients = [0, 0, 0, 0];
        while ingredients == [0, 0, 0, 0] {
            for i in 0..4 {
                ingredients[i] = match rnd.gen_bool(0.6) {
                    true => 0,
                    false => match rnd.gen_bool(0.35 / 0.4) {
                        true => -1,
                        false => -2,
                    },
                }
            }
        }

        /* Generate the cost
            By taking some sample order generated by codingame and plugging them into an online
            multilinear regressor : https://www.statskingdom.com/410multi_linear_regression.html,
            I arrived at the formula:
            price = 8.77 - 2.65*Ingredient[2] - 4.32*Ingredient[3]
        */
        let price: usize =
            (8.77 - 2.65 * ingredients[2] as f32 - 4.32 * ingredients[3] as f32).round() as usize;

        Order {
            id: id,
            ingredients: ingredients,
            price: price,
        }
    }

    fn can_fulfill_order(order: &Order, ingredient_stock: &Ingredients) -> bool {
        ingredient_stock[0] >= -order.ingredients[0]
            && ingredient_stock[1] >= -order.ingredients[1]
            && ingredient_stock[2] >= -order.ingredients[2]
            && ingredient_stock[3] >= -order.ingredients[3]
    }

    fn get_order_idx(orders: &[Option<Order>; 5], order_id: usize) -> Option<usize> {
        for i in 0..orders.len() {
            if let Some(o) = orders[i] {
                if o.id == order_id {
                    return Some(i);
                }
            }
        }
        None
    }

    fn use_ingredient_stock(ingredient_stock: &mut Ingredients, order_reqs: &Ingredients) {
        for i in 0..4 {
            ingredient_stock[i] += order_reqs[i];
        }
    }

    fn valid_moves(
        orders: &[Option<Order>; 5],
        ingredient_stock: &Ingredients,
    ) -> StackVector<Move, 6> {
        let mut valid_moves: StackVector<Move, 6> = StackVector {
            arr: [Move::WAIT; 6],
            len: 0,
        };

        // WAIT is always a valid move
        valid_moves.add(Move::WAIT);

        // Check which order the player can fulfill and add them as a valid move
        for order in orders.iter() {
            if let Some(o) = order {
                if WitchesBrewGame::can_fulfill_order(o, ingredient_stock) {
                    valid_moves.add(Move::BREW(o.id));
                }
            }
        }

        valid_moves
    }
}

impl Game for WitchesBrewGame {
    fn new() -> Self {
        let mut game = WitchesBrewGame {
            moves: [None; 2],
            ingredient_stocks: [[2, 2, 3, 3]; 2],
            rupees: [0; 2],
            brewed_potions_count: [0; 2],

            orders: [None; 5],
            next_order_id: 1,
            rnd: rand::SeedableRng::seed_from_u64(rand::random()),

            active: true,
            active_player: 0,
            turn: 0,
            winners: None,
        };

        // Generate orders
        for i in 0..5 {
            game.orders[i] = Some(WitchesBrewGame::generate_order(
                game.next_order_id,
                &mut game.rnd,
            ));

            game.next_order_id += 1;
        }

        game
    }

    fn turn(&self) -> Option<Message> {
        // If game is over, return None
        if self.active == false {
            return None;
        }

        let mut out: Vec<String> = Vec::new();

        /* (1) Output number of orders */
        // Count # of orders
        let mut nb_orders = 0;
        for order in self.orders.iter() {
            if order.is_some() {
                nb_orders += 1;
            }
        }
        out.push(format!("{}", nb_orders));

        /* (2) Output available actions */
        for order in self.orders.iter() {
            if let Some(o) = order {
                out.push(format!(
                    "{} BREW {} {} {} {} {} 0 0 0 0",
                    o.id,
                    o.ingredients[0],
                    o.ingredients[1],
                    o.ingredients[2],
                    o.ingredients[3],
                    o.price
                ));
            }
        }

        /* (3) Output the active player state */
        let ap = self.active_player as usize;
        out.push(format!(
            "{} {} {} {} {}",
            self.ingredient_stocks[ap][0],
            self.ingredient_stocks[ap][1],
            self.ingredient_stocks[ap][2],
            self.ingredient_stocks[ap][3],
            self.rupees[ap],
        ));

        /* (4) Output the other player state */
        let op = ((self.active_player + 1) % 2) as usize;
        out.push(format!(
            "{} {} {} {} {}",
            self.ingredient_stocks[op][0],
            self.ingredient_stocks[op][1],
            self.ingredient_stocks[op][2],
            self.ingredient_stocks[op][3],
            self.rupees[op],
        ));

        /* (X) Send message */
        Some(Message {
            player_id: self.active_player as usize,
            messages: out,
        })
    }

    fn play(&mut self, msg: String) {
        /* (1) Parse move, assuming it is always in the right format */
        let msg = msg.as_str();
        let _move: Move = match msg {
            "WAIT" => Move::WAIT,
            _ => match &msg[0..5] {
                "BREW " => Move::BREW(parse_input!(msg[5..], usize)),
                _ => {
                    panic!();
                }
            },
        };

        /* (2) Record the move */
        self.moves[self.active_player as usize] = Some(_move);

        /* (3) If it's player'1 turn, i.e. both players have played =>  update the state */
        if self.active_player == 1 {
            /* 3.1 Check if moves were valid */
            let player0_valid_moves =
                WitchesBrewGame::valid_moves(&self.orders, &self.ingredient_stocks[0]);
            let player1_valid_moves =
                WitchesBrewGame::valid_moves(&self.orders, &self.ingredient_stocks[1]);

            let is_move0_valid = player0_valid_moves.get().contains(&self.moves[0].unwrap());
            let is_move1_valid = player1_valid_moves.get().contains(&self.moves[1].unwrap());

            if !is_move0_valid && !is_move1_valid {
                eprintln!(
                    "[GAME] Player 0's move {:?} & Player 1's move {:?} are both invalid",
                    &self.moves[0], &self.moves[1]
                );
                self.active = false;
                self.winners = Some((WinLossTie::Loss, WinLossTie::Loss));
                return;
            } else if is_move0_valid && !is_move1_valid {
                eprintln!("[GAME] Player 1's move {:?} is invalid", &self.moves[1]);
                self.active = false;
                self.winners = Some((WinLossTie::Win, WinLossTie::Loss));
                return;
            } else if !is_move0_valid && is_move1_valid {
                eprintln!("[GAME] Player 0's move {:?} is invalid", &self.moves[0]);
                self.active = false;
                self.winners = Some((WinLossTie::Loss, WinLossTie::Win));
                return;
            }

            /* 3.2 Update the state */
            // For each player move
            for pid in 0..=1 {
                // If it's a BREW move
                if let Move::BREW(order_id) = self.moves[pid].unwrap() {
                    let fullfilled_order_idx =
                        WitchesBrewGame::get_order_idx(&self.orders, order_id).unwrap();

                    // Update the player's potion count
                    self.brewed_potions_count[pid] += 1;

                    // Update the player's rupees
                    self.rupees[pid] += self.orders[fullfilled_order_idx].unwrap().price;

                    // Update the player's ingredient stock
                    WitchesBrewGame::use_ingredient_stock(
                        &mut self.ingredient_stocks[pid],
                        &self.orders[fullfilled_order_idx].unwrap().ingredients,
                    );

                    // Remove fullfilled orders and create new one in its place
                    // TODO: if player 0 & 1 brewed the same potion, I'll be creating a new order twice
                    self.orders[fullfilled_order_idx] = Some(WitchesBrewGame::generate_order(
                        self.next_order_id,
                        &mut self.rnd,
                    ));
                    self.next_order_id += 1;
                }
            }

            /* 3.3 Check terminal condition */
            if self.brewed_potions_count[0] == 2
                || self.brewed_potions_count[1] == 2
                || self.turn == 100
            {
                self.active = false;
                if self.rupees[0] > self.rupees[1] {
                    self.winners = Some((WinLossTie::Win, WinLossTie::Loss));
                } else if self.rupees[0] < self.rupees[1] {
                    self.winners = Some((WinLossTie::Loss, WinLossTie::Win));
                } else {
                    self.winners = Some((WinLossTie::Tie, WinLossTie::Tie));
                }
            }

            /* 3.3 Reinit moves */
            self.moves = [None, None];
            self.turn += 1;
        }
        self.active_player = (self.active_player + 1) % 2;
    }

    fn winners(&self) -> Option<Vec<WinLossTie>> {
        match &self.winners {
            Some(w) => Some(vec![w.0, w.1]),
            None => None,
        }
    }

    fn get_state(&self) -> record::GameState {
        let mut state: HashMap<String, String> = HashMap::new();
        state.insert(String::from("turn"), self.turn.to_string());
        state.insert(String::from("active"), self.active.to_string());
        state.insert(
            String::from("active_player"),
            self.active_player.to_string(),
        );

        state.insert(
            String::from("Moves"),
            format!(
                "[{}, {}]",
                match self.moves[0] {
                    None => String::from("None"),
                    Some(m) => format!("{}", m),
                },
                match self.moves[1] {
                    None => String::from("None"),
                    Some(m) => format!("{}", m),
                }
            ),
        );

        for pid in 0..=1 {
            fn fmt_ingredients(ingredients: &Ingredients) -> String {
                format!(
                    "[🐋: {}, 🍏: {}, 🦧: {}, 💛: {}]",
                    ingredients[0], ingredients[1], ingredients[2], ingredients[3]
                )
            }

            state.insert(
                format!("player[{}]: Stock", pid),
                fmt_ingredients(&self.ingredient_stocks[pid]),
            );

            state.insert(
                format!("player[{}]: Rupees", pid),
                self.rupees[pid].to_string(),
            );

            state.insert(
                format!("player[{}]: Brewed potion count", pid),
                self.brewed_potions_count[pid].to_string(),
            );
        }

        record::GameState { board: None, state }
    }

    fn get_board_representation() -> Option<record::BoardRepresentation> {
        None
    }
}

#[cfg(test)]
mod tests {
    use common::assert_vec_eq;

    use super::*;

    #[test]
    fn test_can_fulfill_order() {
        let stock = [3, 2, 1, 0];
        let order = Order {
            id: 0,
            ingredients: [-1, -1, -1, 0],
            price: 0,
        };
        assert!(WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [0, 0, -1, 0],
            price: 0,
        };
        assert!(WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [-3, -2, -1, 0],
            price: 0,
        };
        assert!(WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [-4, -2, -1, 0],
            price: 0,
        };
        assert!(!WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [-3, -2, -2, 0],
            price: 0,
        };
        assert!(!WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [0, 0, 0, -1],
            price: 0,
        };
        assert!(!WitchesBrewGame::can_fulfill_order(&order, &stock));
    }

    #[test]
    fn test_get_order_idx() {
        let orders: [Option<Order>; 5] = [
            Some(Order {
                id: 4,
                ingredients: [0, 0, 0, -1],
                price: 0,
            }),
            Some(Order {
                id: 41,
                ingredients: [0, 0, 0, -1],
                price: 0,
            }),
            None,
            Some(Order {
                id: 132,
                ingredients: [0, 0, 0, -1],
                price: 0,
            }),
            Some(Order {
                id: 27,
                ingredients: [0, 0, 0, -1],
                price: 0,
            }),
        ];

        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 4), Some(0));
        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 41), Some(1));
        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 132), Some(3));
        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 27), Some(4));
        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 100), None);
    }

    #[test]
    fn test_use_ingredient_stock() {
        let mut stock = [3, 2, 1, 0];
        let order_ings: Ingredients = [-1, -1, -1, 0];

        WitchesBrewGame::use_ingredient_stock(&mut stock, &order_ings);
        let expected_stock: [isize; 4] = [2, 1, 0, 0];
        assert_eq!(stock, expected_stock);

        let mut stock = [3, 2, 1, 0];
        let order_ings: Ingredients = [0, 0, -1, 0];

        WitchesBrewGame::use_ingredient_stock(&mut stock, &order_ings);
        let expected_stock: [isize; 4] = [3, 2, 0, 0];
        assert_eq!(stock, expected_stock);

        let mut stock = [3, 2, 1, 0];
        let order_ings: Ingredients = [-3, -2, -1, 0];

        WitchesBrewGame::use_ingredient_stock(&mut stock, &order_ings);
        let expected_stock: [isize; 4] = [0, 0, 0, 0];
        assert_eq!(stock, expected_stock);
    }

    #[test]
    fn test_valid_moves() {
        let stock = [3, 2, 1, 0];
        let orders: [Option<Order>; 5] = [
            Some(Order {
                id: 4,
                ingredients: [0, 0, 0, -1],
                price: 0,
            }),
            Some(Order {
                id: 41,
                ingredients: [-1, -1, -1, 0],
                price: 0,
            }),
            Some(Order {
                id: 132,
                ingredients: [0, 0, -2, 0],
                price: 0,
            }),
            Some(Order {
                id: 132,
                ingredients: [-3, -2, -1, 0],
                price: 0,
            }),
            Some(Order {
                id: 27,
                ingredients: [-4, -2, -1, 0],
                price: 0,
            }),
        ];

        let expected_valid_moves = [Move::WAIT, Move::BREW(41), Move::BREW(132)];

        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &stock).get(),
            expected_valid_moves
        );
    }
}
