use common::record;
use common::{Game, Message, StackVector, WinLossTie};
use rand::{rngs, Rng};
use std::cmp;
use std::collections::HashMap;
use std::fmt;

macro_rules! parse_input {
    ($x:expr, $t:ident) => {
        $x.trim().parse::<$t>().unwrap()
    };
}
#[derive(Copy, Clone, PartialEq, Debug)]
enum Move {
    NONE,
    WAIT,
    REST,
    BREW(u32),
    CAST(u32),
}

impl Move {
    fn parse_move(msg: &str) -> Move {
        match msg {
            "WAIT" => Move::WAIT,
            "REST" => Move::REST,
            _ => match &msg[0..5] {
                "BREW " => Move::BREW(parse_input!(msg[5..], u32)),
                "CAST " => Move::CAST(parse_input!(msg[5..], u32)),
                _ => {
                    panic!();
                }
            },
        }
    }

    fn to_string(&self) -> String {
        match self {
            Move::NONE => format!("None"),
            Move::WAIT => format!("WAIT"),
            Move::REST => format!("REST"),
            Move::BREW(i) => format!("BREW {}", i),
            Move::CAST(i) => format!("CAST {}", i),
        }
    }
}

type Ingredients = [i8; 4];

#[derive(Copy, Clone)]
struct Order {
    id: u32,
    ingredients: Ingredients,
    delta_stock: i8,
    price: u8,
}

#[derive(Clone)]
struct Spell {
    id: u32,
    ingredients: Ingredients,
    delta_stock: i8,
    active: bool,
}

#[derive(Clone)]
struct Player {
    move_: Move,
    stock: Ingredients,
    empty_slots: i8,
    spells: [Spell; 4],
    rupees: u32,
    brewed_potions_count: u8,
}

pub struct WitchesBrewGame {
    // States per player
    players: [Player; 2],

    // Global states
    orders: [Option<Order>; 5],
    next_order_id: u32,
    rnd: rngs::StdRng, // random number generator

    active: bool,
    active_player: u8,
    turn: u8,
    winners: Option<(WinLossTie, WinLossTie)>,
}

impl WitchesBrewGame {
    fn new_with_seed(seed: u64) -> Self {
        // generate players
        let player = Player {
            move_: Move::NONE,
            stock: [3, 0, 0, 0],
            empty_slots: 7,
            rupees: 0,
            brewed_potions_count: 0,
            spells: WitchesBrewGame::init_spells(),
        };

        let mut game = WitchesBrewGame {
            players: [player.clone(), player.clone()],

            orders: [None; 5],
            next_order_id: 1,
            rnd: rand::SeedableRng::seed_from_u64(seed),

            active: true,
            active_player: 0,
            turn: 0,
            winners: None,
        };

        // Generate orders
        for i in 0..5 {
            game.orders[i] = Some(WitchesBrewGame::generate_order(
                game.next_order_id,
                &mut game.rnd,
            ));

            game.next_order_id += 1;
        }

        game
    }

    fn init_spells() -> [Spell; 4] {
        [
            Spell {
                id: 10,
                ingredients: [2, 0, 0, 0],
                delta_stock: 2,
                active: true,
            },
            Spell {
                id: 11,
                ingredients: [-1, 1, 0, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 12,
                ingredients: [0, -1, 1, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 13,
                ingredients: [0, 0, -1, 1],
                delta_stock: 0,
                active: true,
            },
        ]
    }

    fn generate_order(id: u32, rnd: &mut rngs::StdRng) -> Order {
        /* Generate required ingredients
        For each ingredient, the probabilites are :
            60% : 0
            35% : -1
            5%  : -2

        The loop guarantees that a [0,0,0,0] will never be generated
        */
        let mut ingredients = [0, 0, 0, 0];
        while ingredients == [0, 0, 0, 0] {
            for i in 0..4 {
                ingredients[i] = match rnd.gen_bool(0.6) {
                    true => 0,
                    false => match rnd.gen_bool(0.35 / 0.4) {
                        true => -1,
                        false => -2,
                    },
                }
            }
        }

        let delta_stock = ingredients[0] + ingredients[1] + ingredients[2] + ingredients[3];

        /* Generate the cost
            By taking some sample order generated by codingame and plugging them into an online
            multilinear regressor : https://www.statskingdom.com/410multi_linear_regression.html,
            I arrived at the formula:
            price = 8.77 - 2.65*Ingredient[2] - 4.32*Ingredient[3]

            we cap price to be between 6 and 23
        */
        let mut price: u8 =
            (8.77 - 2.65 * ingredients[2] as f32 - 4.32 * ingredients[3] as f32).round() as u8;
        price = cmp::max(6, price);
        price = cmp::min(price, 23);

        Order {
            id: id,
            ingredients: ingredients,
            delta_stock: delta_stock,
            price: price,
        }
    }

    fn can_fulfill_order(order: &Order, stock: &Ingredients) -> bool {
        stock[0] >= -order.ingredients[0]
            && stock[1] >= -order.ingredients[1]
            && stock[2] >= -order.ingredients[2]
            && stock[3] >= -order.ingredients[3]
    }

    fn can_cast_spell(spell: &Spell, stock: &Ingredients, empty_slots: i8) -> bool {
        if spell.delta_stock > empty_slots {
            return false;
        }
        if spell.active == false {
            return false;
        }

        for i in 0..4 {
            if spell.ingredients[i] < 0 && stock[i] < -spell.ingredients[i] {
                return false;
            }
        }

        true
    }

    fn get_order_idx(orders: &[Option<Order>; 5], order_id: u32) -> Option<usize> {
        for i in 0..orders.len() {
            if let Some(o) = orders[i] {
                if o.id == order_id {
                    return Some(i);
                }
            }
        }
        None
    }

    fn get_spell_idx(spells: &[Spell; 4], spell_id: u32) -> Option<usize> {
        for i in 0..spells.len() {
            if spells[i].id == spell_id {
                return Some(i);
            }
        }
        None
    }

    fn update_ingredient_stock(ingredient_stock: &mut Ingredients, order_reqs: &Ingredients) {
        for i in 0..4 {
            ingredient_stock[i] += order_reqs[i];
        }
    }

    fn valid_moves(
        orders: &[Option<Order>; 5],
        spells: &[Spell; 4],
        stock: &Ingredients,
        empty_slots: i8,
    ) -> StackVector<Move, 10> {
        // There's at max 10 possible moves : 5 orders, 4 spells + REST
        let mut valid_moves: StackVector<Move, 10> = StackVector {
            arr: [Move::NONE; 10],
            len: 0,
        };

        // Check which order the player can fulfill and add them as a valid move
        for order in orders.iter() {
            if let Some(o) = order {
                if WitchesBrewGame::can_fulfill_order(o, stock) {
                    valid_moves.add(Move::BREW(o.id));
                }
            }
        }

        // Check which spell the player can fulfill and add them as a valid move
        // in the meantime check if there are inactive spells
        let mut all_spells_are_active = true;
        for spell in spells.iter() {
            if spell.active == false {
                all_spells_are_active = false;
            } else {
                if WitchesBrewGame::can_cast_spell(spell, stock, empty_slots) {
                    valid_moves.add(Move::CAST(spell.id));
                }
            }
        }

        if all_spells_are_active == false {
            valid_moves.add(Move::REST);
        }

        // At the end, if there's no valid moves, we just send a wait
        if valid_moves.len == 0 {
            valid_moves.add(Move::WAIT);
        }

        valid_moves
    }
}

impl Game for WitchesBrewGame {
    fn new() -> Self {
        // generate players
        let player = Player {
            move_: Move::NONE,
            stock: [3, 0, 0, 0],
            empty_slots: 7,
            rupees: 0,
            brewed_potions_count: 0,
            spells: WitchesBrewGame::init_spells(),
        };

        let mut game = WitchesBrewGame {
            players: [player.clone(), player.clone()],

            orders: [None; 5],
            next_order_id: 1,
            rnd: rand::SeedableRng::seed_from_u64(rand::random()),

            active: true,
            active_player: 0,
            turn: 0,
            winners: None,
        };

        // Generate orders
        for i in 0..5 {
            game.orders[i] = Some(WitchesBrewGame::generate_order(
                game.next_order_id,
                &mut game.rnd,
            ));

            game.next_order_id += 1;
        }

        game
    }

    fn turn(&self) -> Option<Message> {
        // If game is over, return None
        if self.active == false {
            return None;
        }

        let mut out: Vec<String> = Vec::new();

        /* (1) Output number of orders */
        // Count # of orders
        let mut nb_orders = 0;
        for order in self.orders.iter() {
            if order.is_some() {
                nb_orders += 1;
            }
        }
        out.push(format!("{}", nb_orders + 8)); // add the 8 spells of the 2 players

        /* (2) Output available orders */
        for order in self.orders.iter() {
            if let Some(o) = order {
                out.push(format!(
                    "{} BREW {} {} {} {} {} 0 0 0 0",
                    o.id,
                    o.ingredients[0],
                    o.ingredients[1],
                    o.ingredients[2],
                    o.ingredients[3],
                    o.price
                ));
            }
        }

        let active_player: &Player = &self.players[self.active_player as usize];
        let other_player: &Player = &self.players[((self.active_player + 1) % 2) as usize];

        /* (3) Output the active player' spells */
        for spell in active_player.spells.iter() {
            out.push(format!(
                "{} CAST {} {} {} {} 0 0 0 {} 0",
                spell.id,
                spell.ingredients[0],
                spell.ingredients[1],
                spell.ingredients[2],
                spell.ingredients[3],
                match spell.active {
                    true => 1,
                    false => 0,
                }
            ));
        }

        /* (4) Output the other player' spells */
        for spell in other_player.spells.iter() {
            out.push(format!(
                "{} OPPONENT_CAST {} {} {} {} 0 0 0 {} 0",
                spell.id,
                spell.ingredients[0],
                spell.ingredients[1],
                spell.ingredients[2],
                spell.ingredients[3],
                match spell.active {
                    true => 1,
                    false => 0,
                }
            ));
        }

        /* (5) Output the active player' ingeredient stock & rupees */
        out.push(format!(
            "{} {} {} {} {}",
            active_player.stock[0],
            active_player.stock[1],
            active_player.stock[2],
            active_player.stock[3],
            active_player.rupees,
        ));

        /* (5) Output the other player' ingeredient stock & rupees */
        out.push(format!(
            "{} {} {} {} {}",
            other_player.stock[0],
            other_player.stock[1],
            other_player.stock[2],
            other_player.stock[3],
            other_player.rupees,
        ));

        /* (X) Send message */
        Some(Message {
            player_id: self.active_player as usize,
            messages: out,
        })
    }

    fn play(&mut self, msg: String) {
        /* (1) Parse move, assuming it is always in the right format */
        let _move = Move::parse_move(msg.as_str());

        /* (2) Record the move */
        self.players[self.active_player as usize].move_ = _move;

        /* (3) If it's player'1 turn, i.e. both players have played =>  update the state */
        if self.active_player == 1 {
            let player0: &Player = &self.players[0];
            let player1: &Player = &self.players[1];

            /* 3.1 Check if moves were valid */
            let player0_valid_moves = WitchesBrewGame::valid_moves(
                &self.orders,
                &player0.spells,
                &player0.stock,
                player0.empty_slots,
            );
            let player1_valid_moves = WitchesBrewGame::valid_moves(
                &self.orders,
                &player1.spells,
                &player1.stock,
                player1.empty_slots,
            );

            let is_move0_valid = player0_valid_moves.get().contains(&player0.move_);
            let is_move1_valid = player1_valid_moves.get().contains(&player1.move_);

            if !is_move0_valid && !is_move1_valid {
                eprintln!(
                    "[GAME] Player 0's move {:?} & Player 1's move {:?} are both invalid",
                    &player0.move_, &player1.move_
                );
                self.active = false;
                self.winners = Some((WinLossTie::Loss, WinLossTie::Loss));
                return;
            } else if is_move0_valid && !is_move1_valid {
                eprintln!("[GAME] Player 1's move {:?} is invalid", &player1.move_);
                self.active = false;
                self.winners = Some((WinLossTie::Win, WinLossTie::Loss));
                return;
            } else if !is_move0_valid && is_move1_valid {
                eprintln!("[GAME] Player 0's move {:?} is invalid", &player0.move_);
                self.active = false;
                self.winners = Some((WinLossTie::Loss, WinLossTie::Win));
                return;
            }

            /* 3.2 Update the state */
            // For each player move
            let mut orders_to_remove: [Option<usize>; 2] = [None, None];
            for player in self.players.iter_mut() {
                /* If it's a BREW move */
                if let Move::BREW(order_id) = player.move_ {
                    let fullfilled_order_idx =
                        WitchesBrewGame::get_order_idx(&self.orders, order_id).unwrap();

                    let fullfilled_order = &self.orders[fullfilled_order_idx].unwrap();

                    // Update the player's potion count
                    player.brewed_potions_count += 1;

                    // Update the player's rupees
                    player.rupees += fullfilled_order.price as u32;

                    // Update the player's ingredient stock
                    WitchesBrewGame::update_ingredient_stock(
                        &mut player.stock,
                        &fullfilled_order.ingredients,
                    );

                    // Update the player's empty slots
                    player.empty_slots -= fullfilled_order.delta_stock;

                    if orders_to_remove[0] == None {
                        orders_to_remove[0] = Some(fullfilled_order_idx);
                    } else if fullfilled_order_idx != orders_to_remove[0].unwrap() {
                        orders_to_remove[1] = Some(fullfilled_order_idx);
                    }

                /* If it's a CAST move */
                } else if let Move::CAST(spell_id) = player.move_ {
                    let cast_spell_idx =
                        WitchesBrewGame::get_spell_idx(&player.spells, spell_id).unwrap();

                    let cast_spell = &mut player.spells[cast_spell_idx];

                    // Update the player's ingredient stock
                    WitchesBrewGame::update_ingredient_stock(
                        &mut player.stock,
                        &cast_spell.ingredients,
                    );

                    // Update the player's empty slots
                    player.empty_slots -= cast_spell.delta_stock;

                    // Spell is now exhausted
                    cast_spell.active = false;

                /* If it's a REST move */
                } else if Move::REST == player.move_ {
                    for spell in player.spells.iter_mut() {
                        spell.active = true;
                    }
                }
            }

            // Remove fullfilled orders and create new one in their place
            for i in 0..2 {
                if let Some(oix) = orders_to_remove[i] {
                    self.orders[oix] = Some(WitchesBrewGame::generate_order(
                        self.next_order_id,
                        &mut self.rnd,
                    ));
                    self.next_order_id += 1;
                }
            }

            /* 3.3 Check terminal condition */
            let player0: &Player = &self.players[0];
            let player1: &Player = &self.players[1];

            if player0.brewed_potions_count == 3
                || player1.brewed_potions_count == 3
                || self.turn == 100
            {
                self.active = false;

                let score0 = player0.rupees
                    + (player0.stock[1] + player0.stock[2] + player0.stock[3]) as u32;
                let score1 = player1.rupees
                    + (player1.stock[1] + player1.stock[2] + player1.stock[3]) as u32;

                if score0 > score1 {
                    self.winners = Some((WinLossTie::Win, WinLossTie::Loss));
                } else if score0 < score1 {
                    self.winners = Some((WinLossTie::Loss, WinLossTie::Win));
                } else {
                    self.winners = Some((WinLossTie::Tie, WinLossTie::Tie));
                }
            }

            /* 3.3 Reinit moves */
            self.players[0].move_ = Move::NONE;
            self.players[1].move_ = Move::NONE;
            self.turn += 1;
        }
        self.active_player = (self.active_player + 1) % 2;
    }

    fn winners(&self) -> Option<Vec<WinLossTie>> {
        match &self.winners {
            Some(w) => Some(vec![w.0, w.1]),
            None => None,
        }
    }

    fn get_state(&self) -> record::GameState {
        let mut state: HashMap<String, String> = HashMap::new();
        state.insert(String::from("turn"), self.turn.to_string());
        state.insert(String::from("active"), self.active.to_string());
        state.insert(
            String::from("active_player"),
            self.active_player.to_string(),
        );

        state.insert(
            String::from("Moves"),
            format!(
                "[{}, {}]",
                self.players[0].move_.to_string(),
                self.players[1].move_.to_string()
            ),
        );

        fn fmt_order(order: &Order) -> String {
            format!(
                "[{} | {} | 🔸{}]",
                order.id,
                {
                    let tiers = ['🐋', '🍏', '🦧', '💛'];
                    let mut s = String::from("");
                    for i in 0..order.ingredients.len() {
                        if order.ingredients[i] < 0 {
                            s.push_str(&format!("{}{} ", order.ingredients[i], tiers[i]));
                        }
                    }
                    s
                },
                order.price
            )
        }

        state.insert(
            String::from("Orders"),
            self.orders
                .iter()
                .map(|order| match order {
                    None => String::from(""),
                    Some(o) => fmt_order(o),
                })
                .collect::<Vec<String>>()
                .join(", "),
        );

        for pid in 0..=1 {
            let player: &Player = &self.players[pid];

            fn fmt_stock(ingredients: &Ingredients) -> String {
                format!(
                    "[🐋: {}, 🍏: {}, 🦧: {}, 💛: {}]",
                    ingredients[0], ingredients[1], ingredients[2], ingredients[3]
                )
            }

            fn fmt_spell(spell: &Spell) -> String {
                format!(
                    "[{} {} | {}]",
                    match spell.active {
                        true => "🟢",
                        false => "⚪",
                    },
                    spell.id,
                    {
                        let tiers = ['🐋', '🍏', '🦧', '💛'];
                        let mut s = String::from("");
                        for i in 0..spell.ingredients.len() {
                            if spell.ingredients[i] < 0 {
                                s.push_str(&format!("{}{} ", spell.ingredients[i], tiers[i]));
                            }

                            if spell.ingredients[i] > 0 {
                                s.push_str(&format!("+{}{} ", spell.ingredients[i], tiers[i]));
                            }
                        }
                        s
                    }
                )
            }

            state.insert(format!("player[{}]: Stock", pid), fmt_stock(&player.stock));

            state.insert(
                format!("player[{}]: Rupees", pid),
                player.rupees.to_string(),
            );

            state.insert(
                format!("player[{}]: Brewed potion count", pid),
                player.brewed_potions_count.to_string(),
            );

            state.insert(
                format!("player[{}]: Empty slots", pid),
                player.empty_slots.to_string(),
            );

            state.insert(
                format!("player[{}]: Empty slots", pid),
                player.empty_slots.to_string(),
            );

            state.insert(
                format!("player[{}]: Spells", pid),
                player
                    .spells
                    .iter()
                    .map(|s| fmt_spell(s))
                    .collect::<Vec<String>>()
                    .join(","),
            );

            let valid_moves = WitchesBrewGame::valid_moves(
                &self.orders,
                &player.spells,
                &player.stock,
                player.empty_slots,
            );
            state.insert(
                format!("player[{}]: Valid moves", pid),
                valid_moves
                    .get()
                    .iter()
                    .map(|m| m.to_string())
                    .collect::<Vec<String>>()
                    .join(", "),
            );
        }

        record::GameState { board: None, state }
    }

    fn get_board_representation() -> Option<record::BoardRepresentation> {
        None
    }
}

#[cfg(test)]
mod tests {
    use std::iter::empty;

    use common::assert_vec_eq;

    use super::*;

    #[test]
    fn test_can_fulfill_order() {
        let stock = [3, 2, 1, 0];

        let order = Order {
            id: 0,
            ingredients: [-1, -1, -1, 0],
            delta_stock: -3,
            price: 0,
        };
        assert!(WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [0, 0, -1, 0],
            delta_stock: -1,
            price: 0,
        };
        assert!(WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [-3, -2, -1, 0],
            delta_stock: -6,
            price: 0,
        };
        assert!(WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [-4, -2, -1, 0],
            delta_stock: -7,
            price: 0,
        };
        assert!(!WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [-3, -2, -2, 0],
            delta_stock: -7,
            price: 0,
        };
        assert!(!WitchesBrewGame::can_fulfill_order(&order, &stock));

        let order = Order {
            id: 0,
            ingredients: [0, 0, 0, -1],
            delta_stock: -1,
            price: 0,
        };
        assert!(!WitchesBrewGame::can_fulfill_order(&order, &stock));
    }

    #[test]
    fn test_can_cast_spell() {
        let mut spells = [
            Spell {
                id: 10,
                ingredients: [2, 0, 0, 0],
                delta_stock: 2,
                active: true,
            },
            Spell {
                id: 11,
                ingredients: [-1, 1, 0, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 12,
                ingredients: [0, -1, 1, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 13,
                ingredients: [0, 0, -1, 1],
                delta_stock: 0,
                active: true,
            },
        ];

        let stock = [3, 0, 0, 0];
        let empty_slots: i8 = 7;

        assert!(WitchesBrewGame::can_cast_spell(
            &spells[0],
            &stock,
            empty_slots
        ));
        assert!(WitchesBrewGame::can_cast_spell(
            &spells[1],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[2],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[3],
            &stock,
            empty_slots
        ));

        /* */
        let stock = [0, 0, 0, 0];
        let empty_slots: i8 = 10;

        assert!(WitchesBrewGame::can_cast_spell(
            &spells[0],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[1],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[2],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[3],
            &stock,
            empty_slots
        ));

        /* */
        let stock = [1, 1, 0, 0];
        let empty_slots: i8 = 8;

        assert!(WitchesBrewGame::can_cast_spell(
            &spells[0],
            &stock,
            empty_slots
        ));
        assert!(WitchesBrewGame::can_cast_spell(
            &spells[1],
            &stock,
            empty_slots
        ));
        assert!(WitchesBrewGame::can_cast_spell(
            &spells[2],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[3],
            &stock,
            empty_slots
        ));

        /* */
        let stock = [1, 1, 1, 0];
        let empty_slots: i8 = 7;

        assert!(WitchesBrewGame::can_cast_spell(
            &spells[0],
            &stock,
            empty_slots
        ));
        assert!(WitchesBrewGame::can_cast_spell(
            &spells[1],
            &stock,
            empty_slots
        ));
        assert!(WitchesBrewGame::can_cast_spell(
            &spells[2],
            &stock,
            empty_slots
        ));
        assert!(WitchesBrewGame::can_cast_spell(
            &spells[3],
            &stock,
            empty_slots
        ));

        /* */
        let stock = [9, 0, 0, 0];
        let empty_slots: i8 = 1;

        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[0],
            &stock,
            empty_slots
        ));
        assert!(WitchesBrewGame::can_cast_spell(
            &spells[1],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[2],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[3],
            &stock,
            empty_slots
        ));

        /* */
        let stock = [9, 0, 0, 0];
        let empty_slots: i8 = 1;
        spells[1].active = false;

        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[0],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[1],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[2],
            &stock,
            empty_slots
        ));
        assert!(!WitchesBrewGame::can_cast_spell(
            &spells[3],
            &stock,
            empty_slots
        ));
    }

    #[test]
    fn test_get_order_idx() {
        let orders: [Option<Order>; 5] = [
            Some(Order {
                id: 4,
                ingredients: [0, 0, 0, -1],
                delta_stock: -1,
                price: 0,
            }),
            Some(Order {
                id: 41,
                ingredients: [0, 0, 0, -1],
                delta_stock: -1,
                price: 0,
            }),
            None,
            Some(Order {
                id: 132,
                ingredients: [0, 0, 0, -1],
                delta_stock: -1,
                price: 0,
            }),
            Some(Order {
                id: 27,
                ingredients: [0, 0, 0, -1],
                delta_stock: -1,
                price: 0,
            }),
        ];

        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 4), Some(0));
        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 41), Some(1));
        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 132), Some(3));
        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 27), Some(4));
        assert_eq!(WitchesBrewGame::get_order_idx(&orders, 100), None);
    }

    #[test]
    fn test_get_spell_idx() {
        let spells = [
            Spell {
                id: 10,
                ingredients: [2, 0, 0, 0],
                delta_stock: 2,
                active: true,
            },
            Spell {
                id: 11,
                ingredients: [-1, 1, 0, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 12,
                ingredients: [0, -1, 1, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 13,
                ingredients: [0, 0, -1, 1],
                delta_stock: 0,
                active: true,
            },
        ];

        assert_eq!(WitchesBrewGame::get_spell_idx(&spells, 10), Some(0));
        assert_eq!(WitchesBrewGame::get_spell_idx(&spells, 11), Some(1));
        assert_eq!(WitchesBrewGame::get_spell_idx(&spells, 12), Some(2));
        assert_eq!(WitchesBrewGame::get_spell_idx(&spells, 13), Some(3));
        assert_eq!(WitchesBrewGame::get_spell_idx(&spells, 14), None);
    }

    #[test]
    fn test_update_ingredient_stock() {
        let mut stock = [3, 2, 1, 0];
        let order_ings: Ingredients = [-1, -1, -1, 0];

        WitchesBrewGame::update_ingredient_stock(&mut stock, &order_ings);
        let expected_stock: [i8; 4] = [2, 1, 0, 0];
        assert_eq!(stock, expected_stock);

        /* */
        let mut stock = [3, 2, 1, 0];
        let order_ings: Ingredients = [0, 0, -1, 0];

        WitchesBrewGame::update_ingredient_stock(&mut stock, &order_ings);
        let expected_stock: [i8; 4] = [3, 2, 0, 0];
        assert_eq!(stock, expected_stock);

        /* */
        let mut stock = [3, 2, 1, 0];
        let order_ings: Ingredients = [-3, -2, -1, 0];

        WitchesBrewGame::update_ingredient_stock(&mut stock, &order_ings);
        let expected_stock: [i8; 4] = [0, 0, 0, 0];
        assert_eq!(stock, expected_stock);

        /* */
        let mut stock = [3, 2, 1, 0];
        let order_ings: Ingredients = [2, 0, 0, 0];

        WitchesBrewGame::update_ingredient_stock(&mut stock, &order_ings);
        let expected_stock: [i8; 4] = [5, 2, 1, 0];
        assert_eq!(stock, expected_stock);

        /* */
        let mut stock = [3, 2, 1, 0];
        let order_ings: Ingredients = [-1, 1, 0, 0];

        WitchesBrewGame::update_ingredient_stock(&mut stock, &order_ings);
        let expected_stock: [i8; 4] = [2, 3, 1, 0];
        assert_eq!(stock, expected_stock);
    }

    #[test]
    fn test_valid_moves() {
        let mut stock = [3, 0, 0, 0];
        let mut empty_slots = 7;
        let mut spells = [
            Spell {
                id: 10,
                ingredients: [2, 0, 0, 0],
                delta_stock: 2,
                active: true,
            },
            Spell {
                id: 11,
                ingredients: [-1, 1, 0, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 12,
                ingredients: [0, -1, 1, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 13,
                ingredients: [0, 0, -1, 1],
                delta_stock: 0,
                active: true,
            },
        ];

        let orders: [Option<Order>; 5] = [
            Some(Order {
                id: 1,
                ingredients: [-2, 0, -3, 0],
                delta_stock: -5,
                price: 0,
            }),
            Some(Order {
                id: 2,
                ingredients: [-2, -2, 0, 0],
                delta_stock: -4,
                price: 0,
            }),
            Some(Order {
                id: 3,
                ingredients: [0, -3, 0, -2],
                delta_stock: -5,
                price: 0,
            }),
            Some(Order {
                id: 4,
                ingredients: [0, 0, 0, -5],
                delta_stock: -5,
                price: 0,
            }),
            Some(Order {
                id: 5,
                ingredients: [-2, 0, 0, -2],
                delta_stock: -4,
                price: 0,
            }),
        ];

        let expected_valid_moves = [Move::CAST(10), Move::CAST(11)];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [5, 0, 0, 0];
        empty_slots = 5;
        spells[0].active = false;

        let expected_valid_moves = [Move::CAST(11), Move::REST];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [4, 1, 0, 0];
        empty_slots = 5;
        spells[1].active = false;

        let expected_valid_moves = [Move::CAST(12), Move::REST];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [4, 0, 1, 0];
        empty_slots = 5;
        spells[2].active = false;

        let expected_valid_moves = [Move::CAST(13), Move::REST];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [4, 0, 0, 1];
        empty_slots = 5;
        spells[3].active = false;

        let expected_valid_moves = [Move::REST];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [4, 0, 0, 1];
        empty_slots = 5;
        for spell in spells.iter_mut() {
            spell.active = true;
        }

        let expected_valid_moves = [Move::CAST(10), Move::CAST(11)];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [5, 0, 0, 2];
        empty_slots = 3;
        for spell in spells.iter_mut() {
            spell.active = true;
        }

        let expected_valid_moves = [Move::CAST(10), Move::CAST(11), Move::BREW(5)];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [2, 2, 2, 2];
        empty_slots = 2;
        for spell in spells.iter_mut() {
            spell.active = true;
        }

        let expected_valid_moves = [
            Move::CAST(10),
            Move::CAST(11),
            Move::CAST(12),
            Move::CAST(13),
            Move::BREW(2),
            Move::BREW(5),
        ];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [2, 2, 2, 2];
        empty_slots = 2;
        spells[1].active = false;

        let expected_valid_moves = [
            Move::CAST(10),
            Move::CAST(12),
            Move::CAST(13),
            Move::BREW(2),
            Move::BREW(5),
            Move::REST,
        ];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [2, 4, 2, 2];
        empty_slots = 0;
        for spell in spells.iter_mut() {
            spell.active = true;
        }

        let expected_valid_moves = [
            Move::CAST(11),
            Move::CAST(12),
            Move::CAST(13),
            Move::BREW(2),
            Move::BREW(3),
            Move::BREW(5),
        ];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );

        /* */
        stock = [10, 0, 0, 0];
        empty_slots = 0;
        for spell in spells.iter_mut() {
            spell.active = false;
        }
        spells[0].active = true;

        let expected_valid_moves = [Move::REST];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );
    }

    #[test]
    fn test_valid_moves_no_move() {
        let mut stock = [0, 0, 0, 10];
        let mut empty_slots = 0;
        let mut spells = [
            Spell {
                id: 10,
                ingredients: [2, 0, 0, 0],
                delta_stock: 2,
                active: true,
            },
            Spell {
                id: 11,
                ingredients: [-1, 1, 0, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 12,
                ingredients: [0, -1, 1, 0],
                delta_stock: 0,
                active: true,
            },
            Spell {
                id: 13,
                ingredients: [0, 0, -1, 1],
                delta_stock: 0,
                active: true,
            },
        ];

        let orders: [Option<Order>; 5] = [
            Some(Order {
                id: 1,
                ingredients: [-2, 0, -3, 0],
                delta_stock: -5,
                price: 0,
            }),
            Some(Order {
                id: 2,
                ingredients: [-2, -2, 0, 0],
                delta_stock: -4,
                price: 0,
            }),
            Some(Order {
                id: 3,
                ingredients: [0, -3, 0, -2],
                delta_stock: -5,
                price: 0,
            }),
            Some(Order {
                id: 4,
                ingredients: [-5, 0, 0, 0],
                delta_stock: -5,
                price: 0,
            }),
            Some(Order {
                id: 5,
                ingredients: [-2, 0, 0, -2],
                delta_stock: -4,
                price: 0,
            }),
        ];

        let expected_valid_moves = [Move::WAIT];
        assert_vec_eq!(
            WitchesBrewGame::valid_moves(&orders, &spells, &stock, empty_slots,).get(),
            expected_valid_moves
        );
    }
}
